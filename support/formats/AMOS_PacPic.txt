The file format of AMOS Pac.Pic. images.

by Stuart Caie <kyzer@4u.net>

First draft, 23 February 2002.

Pac.Pic. images are generated by the "Compact" extension in AMOS, using
the PACK" command, e.g. "PACK 0 TO 6" will compress the image on screen 0
into bank number 6. These banks can then be saved as part of the AMOS
source code, or saved as individual bank files.

AMOS records details about the physical hardware screen that the picture
is displayed on (all the required details to re-perform the SCREEN OPEN
and SCREEN DISPLAY command, if the picture is unpacked to a screen number
that doesn't exist).

It is also possible to only pack an area of the screen. Therefore,
seperate screen and picture headers.

All integers are big-endian.

Overall format:
20 bytes: standard AMOS bank header
90 bytes: screen header
24 bytes: picture header
x bytes:  PICDATA stream

Standard AMOS bank header format:
4 bytes: "AmBk"
2 bytes: bank number (1-15)
2 bytes: 0 for CHIP mem bank, 1 for FAST mem bank
4 bytes: bits27-0=bank length, bit31=try fastmem, bit30=try chipmem
8 bytes: bank name. Padded with spaces.
         Reserved names: Music, Amal, Menu, Datas, Work, Asm

Screen header format:
4 bytes:  screen header ID, 0x12031990 (31-December-1990, birth of AMOS?)
2 bytes:  screen width in pixels, e.g. 0x0140 for 320 pixels
2 bytes:  screen height in pixels, e.g. 0x00C8 for 200 pixels
2 bytes:  hardware top-left x coordinate. Amiga DIWSTRT units, e.g. 0x0081
2 bytes:  hardware top-left y coordinate. Amiga DIWSTRT units, e.g. 0x0032
2 bytes:  hardware screen width.
2 bytes:  hardware screen height
2 bytes:  unknown
2 bytes:  unknown
2 bytes:  contents of BPLCON0 (details the Amiga hardware screen mode)
2 bytes:  number of colours. One of  2, 4, 8, 16, 32, 64 or 4096.
2 bytes:  number of bitplanes
64 bytes: 32 2-byte palette entries, Amiga COLORxx register format.

Picture header format:
4 bytes: picture header ID, 0x06071963, (7-June-1963, birth of Francois?)
2 bytes: picture X offset in bytes, within screen
2 bytes: picture Y offset in lines, within screen
2 bytes: picture width in bytes, within screen
2 bytes: picture height in "line lumps", within screen
2 bytes: number of lines in a "line lump".
2 bytes: number of bitplanes
4 bytes: offset to RLEDATA stream, relative to picture header ID's offset.
4 bytes: offset to POINTS stream, relative to picture header ID's offset.

PICDATA/RLEDATA/POINTS stream format:

First, the data in the screen is reordered:
- we compress bitplane 0, then bitplane 1, bitplane 2...
- within a bitplane, we compress a 'lump' of complete lines,
  working from y=0 towards y=height-1
- within a lump, we compress blocks of 8 pixels by lumpheight pixels,
  from x=0, 8, 16, 24, 32 ... to width
- within that block, we compress from top to bottom. As 8 pixels in
  one bitplane is 1 byte, that is the stream to compress.

The size LUMPHEIGHT is varied to get the best compression.

With that stream, we look at each byte.
- We always store the first picture byte.
- For each picture byte, we store 1 RLE bit, to say whether this
  picture byte is repeated or not. The RLE bits are stored in the
  RLEDATA stream, from most significant to least significant bit of a byte.
- If a picture byte is different from the previous, we store a '1'
  as the RLE bit, and we output that picture byte to the PICDATA stream.
- If a picture byte is the same as the previous, we store a '0' as the
  RLE bit, and do noe write anything to the PICDATA stream.

Once the PICDATA and RLEDATA streams are completed, we compress the
RLEDATA by the same method as we compressed the raw bitmap! Now, the
output of this is 'RLEDATA', and the RLE bits generated by this are
in the POINTS stream.
